<section data-type="introduction" id="_introduction">
<h1>Introducción</h1>

<blockquote data-type="epigraph">
<p>“Soy dos con la naturaleza.”</p>

<p data-type="attribution">— Woody Allen</p>
</blockquote>

<p>Nos encontramos aquí: en el inicio. Bueno, casi en el inicio. Si ha pasado un tiempo desde que has escrito cualquier tipo de programación en Processing (o cualquier tipo de matemáticas), esta introducción llevará tu mente de regreso hacia el pensamiento computacional antes de que nos acerquemos a materiales más difíciles y complejos.</p>

<p>En el Capítulo 1, vamos a hablar acerca del concepto de un vector y cómo nos puede servir de manera de un building block para la simulación de movimiento a lo largo del libro. Pero antes de que demos ese paso, pensemos lo que significa que algo simplemente se mueva por la pantalla. Comencemos con uno de las simulaciones de moviemiento más conocidas — El caminante aleatorio.</p>

<section data-type="sect1" id="intro_section1">
<h2>I.1 Caminata Aleatoria</h2>

<a data-primary="random walks" data-type="indexterm"></a>

<p>Imagina que estás de pie en medio de una barra de equilibrio. Cada diez segundos lanzas una moneda al aire. Cara, das un paso hacia adelante. Sello, das un paso hacia atrás. Esto define una caminata aleatoria —un camino definido por una serie de pasos aleatorios. Llevando la barra de equilibrio hacia el suelo, podrías realizar un paseo aleatorio en dos dimensiones, lanzando la moneda dos veces con los siguients resultados:</p>

<table>
	<thead>
		<tr>
			<th>Lanzamiento  1</th>
			<th>Lanzamiento  2</th>
			<th>Resultado</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>
			<p>Cara</p>
			</td>
			<td>
			<p>Cara</p>
			</td>
			<td>
			<p>Paso hacia adelante.</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>Cara</p>
			</td>
			<td>
			<p>Sello</p>
			</td>
			<td>
			<p>Paso hacia la derecha.</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>Sello</p>
			</td>
			<td>
			<p>Cara</p>
			</td>
			<td>
			<p>Paso hacia la izquierda.</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>Sello</p>
			</td>
			<td>
			<p>Sello</p>
			</td>
			<td>
			<p>Paso hacia atrás.</p>
			</td>
		</tr>
	</tbody>
</table>

<p>Pareciera que es particularmente un algoritmo poco sofisticado. Sin embargo, las caminata aleatorias pueden ser usadas para modelar fenómenos que ocurren en el mundo real, desde el movimiento de moléculas en un gas, hasta el comportamiento de un apostador a lo largo de un día en el casino. En cuanto a nosotros, empezaremos este libro estudiando un paseo aleatorio con tres metas en mente.</p>

<a data-primary="natural phenomena" data-secondary="modeling with random walks" data-type="indexterm"></a>

<ol>
	<li>
	<p>Necesitamos repasar un concepto de programación central —Programación Orientada a Objetos. El caminante aleatorio nos servirá como modelo para que el diseño orientado a objetos que usemos haga que cosas se muevan dentro de la ventana de Processing.</p>
	</li>
	<li>
	<p>La caminata aleatoria induce las dos preguntas que nos haremos a través de todo este libro: "¿Cómo definimos las reglas que gobiernan el comportamiento de nuestros objetos?" y luego "¿Cómo implementamos estas reglas en Processing?"</p>
	</li>
	<li>
	<p>A través del libro, periódicamente necesitaremos un entendimiendo básico de aleatoriedad, probabilidad y Perlin Noise. La caminata aleatoria nos permitirá demostrar algunos puntos importantes que nos serán útiles más adelante.</p>
	</li>
</ol>
</section>

<section data-type="sect1" id="intro_section2">
<h2>I.2 La Clase del Caminante Aleatorio</h2>
<p><em>En Processing se escribe 'class' pero usaremos la palabra clase.</em></p>

<a data-primary="object-oriented programming" data-secondary="review of" data-type="indexterm"></a> <a data-primary="Processing" data-secondary="review of object-oriented programming with" data-type="indexterm"></a>

<p>Repasemos un poco la programación orientada a objetos (POO) primero, construyendo un objeto <span class="klass">Caminante</span>. Esta será solamente un revisión superficial. Si nunca has trabajado con POO antes, y tal vez quieras algo más comprensible; Te sugiero detenerte aquí y revisar <a href="http://processing.org/learning/objects/">los conceptos básicos de Processing</a> en el sitio web antes de continuar.</p>

<a data-primary="object" data-secondary="defined" data-type="indexterm"></a> <a data-primary="object-oriented programming" data-secondary="object" data-type="indexterm"></a>

<p>Un <strong><em>objecto</em></strong> en Processing es una entidad que tiene datos y funcionalidad. Estamos tratando de diseñar un objeto <span class="klass">Caminante</span> que a la vez que lleva el seguimiento de sus propios datos (donde existe en la pantalla) y tiene la capacidad de realizar ciertas acciones (así como dibujarse a sí mismo o dar un paso).</p>

<a data-primary="class (Processing)" data-secondary="defined" data-type="indexterm"></a> <a data-primary="object-oriented programming" data-secondary="class" data-type="indexterm"></a>

<p>Una <strong><em>class</em></strong> es la plantilla para construir casos reales de objetos. Piensa en una classe como el cortador de galletas: los objetos son las galletas en sí.</p>

<p>Comenzemos por definir la clase <span class="klass">Caminante</span> lo que significa ser un objeto <span class="klass">Caminante</span>. El <span class="klass">Caminante</span> sólo necesita dos piezas de datos —un número para su posición en x y uno para su posición en y.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
class Caminante {
  // Objetos tienen datos.
  int x;
  int y;</pre>

<a data-primary="class (Processing)" data-secondary="constructor" data-type="indexterm"></a> <a data-primary="constructor" data-type="indexterm"></a>

<p>Cada clase debe tener un constructor, una función especial que es llamada cuando el objeto se crea por primera vez. Puedes pensarla como el <span class="function">setup()</span>del objeto. Ahí, inicializaremos la posición inicial del <span class="klass">Caminante</span><code>’</code> (en este caso, el centro de la pantalla).</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  //Objetos tienen un constructor en donde son inicializados.
  Caminante() {
    x = width/2;
    y = height/2;
  }</pre>

<a data-primary="class (Processing)" data-secondary="functionality" data-type="indexterm"></a> <a data-primary="functionality" data-type="indexterm"></a>

<p>Finalmente, además de los datos, las clases pueden ser definidas con funcionalidad. En este ejemplo, un <span class="klass">Caminante</span> tiene dos funciones. Primero escribiremos una función que permita al objeto mostraste a sí mismo (como un punto blanco).</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  // Objetos tienen funciones.	
  void mostrar() {
    stroke(0);
    point(x,y);
  }</pre>

<p>La segunda función dirige al objeto <span class="klass">Walker</span> para que de un paso. Ahora, aquí es donde las cosas se vuelven un poco más interesantes. ¿Recuerdas el piso en donde estábamos dando pasos aleatorios? Bueno, ahora podemos usar una ventana de Processing con esa misma capacidad. En donde hay cuatro posibles pasos. Un paso hacia la derecha puede ser simulado a través del increimente de <span class="var">x</span> (<span class="var">x</span><code>++</code>); hacia la izquierda con el decremento de <span class="var">x</span> (<span class="var">x--</span>); hacia adelante yendo un pixel hacia abajo (<span class="var">y++</span>); y hacia atrás yendo un pixel hacia arriba (<span class="var">y--</span>). ¿Cómo elegimos desde estas cuatro opciones? Previamente declaramos que podríamos lanzar dos monedas. En Processing, sin embargo, cuando queremos elegir aleatoriamente entre una lista de opciones, podemos elegir un número aleatorio usando <span class="function">random()</span>.</p>

<a data-primary="random number generators" data-secondary="random() function" data-type="indexterm"></a> <a data-primary="random() function" data-type="indexterm"></a>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  void paso() {
    // 0, 1, 2, or 3
    int alternativa = int(random(4));</pre>

<p>La línea de código superior elige un número de punto flotante entre 0 y 4 y lo conviernte en un entero, con un resultado de 0, 1, 2, o 3. Técnicamente hablando, el número más grande nunca será 4.0, sino que 3.999999999 (con tantos 9 como espacios de decimal existentes); como en el proceso de convertir a un entero se elimina la parte decimal, el <span class="var">int</span> más alto que obtendramos será 3. A continuación, tomamos el paso apropiado (izquierda, derecha, arriba, o abajo) dependiendo de cual número aleatorio fue elegido.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
    //{!9} La "alternativa" aleatoria determina nuestro paso.
    if (alternativa == 0) {
      x++;
    } else if (alternativa == 1) {
      x--;
    } else if (alternativa == 2) {
      y++;
    } else {
      y--;
    }
  }
}</pre>

<p>Ahora que hemos escrito la clase, es momento de crear un objeto <span class="klass">Caminante</span> actual en la parte principal de nuestro dibujo—<span class="function">setup()</span> y <span class="function">draw()</span>. Asumiento que estamos buscando modelar una caminata aleatoria singular, declaramos una variable globar del tipo <span class="var">Caminante</span>.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
// Un objeto Caminante
Caminante c;</pre>

<a data-primary="new operator (objects)" data-type="indexterm"></a> <a data-primary="object" data-secondary="new operator" data-type="indexterm"></a>

<p>Luego creamos el objeto en <span class="function">setup()</span> llamando al constructor con el operador <span class="function">new</span>.</p>

<div data-type="example">
<h5>Ejemplo I.1: Caminata aleatoria tradicional</h5>
</div>

<p><em>Cada vez que veas el título Ejemplo en este libro, quiere decir que existe el correspondiente ejemplo en código disponible en <a href="http://github.com/shiffman/The-Nature-of-Code-Examples">GitHub</a>.</em></p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
void setup() {
  size(640,360);
  // {!1 .bold} rear el Caminante.
  c = new Caminante();
  background(255);
}</pre>

<p>Finalmente, durante cada ciclo a través de <span class="function">draw()</span>, le pedimos al <span class="klass">Caminante</span> que de un paso y dibuje un punto.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
void draw() {
  //{!2 .bold} Llama a las funciones en el Caminante.
  c.paso();
  c.mostrar();
}</pre>

<p>Ya que solamente dibujamos el fondo una vez en <span class="function">setup()</span>, en lugar de limpiarlo continuamente cada vez en <span class="function">draw()</span>, vemos el rastro de la caminata aleatoria en nuestra ventana de Processing.</p>

<figure class="screenshot" data-pde="processingjs/intro/_I_1_RandomWalkTraditional/_I_1_RandomWalkTraditional.pde processingjs/intro/_I_1_RandomWalkTraditional/Walker.pde"><img alt="intro ex01" src="intro/intro_ex01.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p>Hay una serie de mejoras que podemos hacer al caminante aleatorio. Por un lado, las alternativas de pasos que tiene el <span class="klass">Walker</span> están limitadas a cuatro opciones —arriba, abajo, izquierda, y derecha. Pero, cualquier pixel en la ventana tiene ocho posibles vecinos, y una novena posibilidad es quedarse en el mismo lugar.</p>

<figure id="intro_figure1"><img alt="Figure I.1" src="intro/intro_01.png" />
<figcaption>Figura I.1</figcaption>
</figure>

<p>Para implementar un objeto <span class="klass">Walker</span> que pueda dar un paso hacia cualquier pixel vecino (o no moverse), podemos elegir un número entre 0 y 8 (nueve posibles alternativas). Sin embargo, una manera más eficiente de escribir el código sería simplemente elegir entre tres posibles pasos en el eje x (-1, 0, o 1) y tres posibles pasos en el eje y.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  void paso() {
    //{!2} Entrega -1, 0, or 1
    int pasox = int(random(3))-1;
    int pasoy = int(random(3))-1;
    x += pasox;
    y += pasoy;
  }</pre>

<p>Llevando esto más adelante, podemos usar números de punto flotante (p.ej. númers decimales) para x e y, y mover de acuerdo a un valor arbitrario aleatorio entre -1 y 1.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  void paso() {
    //{!2} Entrega cualquier número de punto flotante entre -1.0 y 1.0
    float pasox = random(-1, 1);
    float pasoy = random(-1, 1);
    x += pasox;
    y += pasoy;
  }</pre>

<p>Todas estas variaciones en la caminada aleatoria "tradicional" tienen una cosa en común: en cualquier momento en el tiempo, la probabilidad de que el <span class="klass">Caminante</span> de un paso en una dirección específica es igual a la probabilidad de que el <span class="klass">Caminante</span> de un paso en cualquier dirección. En otras palabras, si hay cuatro posibles pasos, hay 1 en 4 (o 25%) chances de que el <span class="klass">Caminante</span> tome una de esos pasos. Con nueve posibles pasos, es 1 en 9 (o 11%) chances.</p>

<a data-primary="random number generators" data-secondary="uniform number distributions and" data-type="indexterm"></a> <a data-primary="uniform number distributions" data-type="indexterm"></a>

<p>Convenientemente, así es como la función <span class="function">random()</span> funciona. El generador de números aleatorios de Processing (que trabaja detrás de cámaras) produce lo que es conocida como una distribución de numeros "uniforme". Podemos probar esta distribución con un sketch de Processing que cuenta cada vez qye un número aleatorio es elegido y lo grafica como la altura de un rectángulo.</p>

<figure class="screenshot" data-pde="processingjs/intro/_I_2_RandomDistribution/_I_2_RandomDistribution.pde"><img alt="intro ex02" src="intro/intro_ex02.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<div data-type="example">
<h5>Ejemplo I.2: Distribución aleatoria de números</h5>
</div>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
//{!1} Una lista para seguir la cuenta de cuan seguidos los números aleatorios son elegidos
int[] cuentasAleatorias;

void setup() {
  size(640, 240);
  cuentasAleatorias = new int[20];
}

void draw() {
  background(255);

  //{!2} Toma un número aleatorio e incrementa la cuenta
  int indice = int(random(cuentasAleatorias.length));
  cuentasAleatorias[indice]++;

  stroke(0);
  fill(175);
  int ancho = width/cuentasAleatorias.length;
  //{!3} Graficando los resultados
  for (int x = 0; x &lt; cuentasAleatorias.length; x++) {
    rect(x*w, height-cuentasAleatorias[x],
		     w-1, cuentasAleatorias[x]);
  }
}</pre>

<p>La captura de pantalla superior muestra los resultados del sketch corriendo por unos minutos. Notemos como cada barra del gráfico difiere en altura. El tamaño de nuestra muestra (p.ej. el número de números aleatorios que hemos elegido) es más bien pequeño y hay algunas discrepancias ocasionales, donde algunos números son elegidos más a menudo. A través del tiempo, con un bueno generador de números aleatorios, esto podría igualar.</p>

<a data-primary="pseudo-random numbers" data-type="indexterm"></a> <a data-primary="random number generators" data-secondary="pseudo-random numbers" data-type="indexterm"></a>

<div data-type="note">
<h2>Números Seudo-Aleatorios</h2>

<p>Los números aleatorios que obtenemos de la función <span class="function">random()</span> no son verdaderamente aleatorios;  por lo tanto se conocen como "seudo-aleatorios." Son el resultado de una función matemática que simula aleatoriedad. Esta función producirá un patrón a través del tiempo, pero ese período de tiempo es tan largo que para nosotros, ¡es tan bueno como aleatoriedad pura!</p>
</div>

<div data-type="exercise" id="intro_exercise1">
<h5>Ejercicio I.1</h5>

<p>Crea un caminante aleatorio con tendendia a moverse hacia abajo y a la derecha. (Veremos la solución en la siguiente sección.)</p>
</div>
</section>

<section data-type="sect1" id="intro_section3">
<h2>I.3 Probabilidad y Distribución No-Uniforme</h2>

<a data-primary="natural phenomena" data-secondary="modeling with the random() function" data-type="indexterm"></a> <a data-primary="non-uniform distributions" data-secondary="probability and" data-type="indexterm"></a> <a data-primary="distributions" data-secondary="non-uniform" data-tertiary="probability and" data-type="indexterm"></a> <a data-primary="probability" data-secondary="non-uniform distributions and" data-type="indexterm"></a> <a data-primary="random number generators" data-secondary="non-uniform distributions" data-tertiary="creating" data-type="indexterm"></a> <a data-primary="random() function" data-secondary="natural phenomena" data-tertiary="modeling with" data-type="indexterm"></a>

<p>¿Recuerdas cuando empezaste a programar por primera vez en Processing? Quizás quisiste dibujar muchos círculos en la pantalla. Entonces te dijiste: "Oh, ya sé. Dibujaré todos estos círculos en posiciones aleatorias, con tamaños aleatorios y colores aleatorios." En un sistema de gráficos computacionales a menudo es fácil llenar un sistema con aleatoriedad. En este libro, sin embargo, estamos buscando construir sistemas modelados en lo que vemos en la naturaleza. Dejar todo a la aleatoriedad no es particularmente una solución acertiv a un problema de diseño —en particular, el tipo de problemas que implican crear una simulación orgánica o de aspecto natural.</p>

<a data-primary="probability of the fittest" data-type="indexterm"></a>

<p>Con algunos trucos, podemos cambiar la manera en que usamos <span class="function">random()</span> para producir distribuciones "no-uniformes" de números aleatorios. Ésto nos será muy útil a través del libro mientras a un número de diferentes escenarios. Cuando examinamos algoritmos genéticos, por ejemplo, necesitaremos una metodología para representar la "selección" —¿cuales miembros de nuesta población deberán ser seleccionados para traspasar su ADN hacia la próxima generación? ¿Recuerdas el concepto de la supervivencia del mejor adaptado? Digamos que tenemos una población de monos evolucionando. No cada mono tendrá las mismas chances de reproducción. Para simular la evolución Darwiniana, no podemos simplemente tomar dos monos aleatoriamente para ser padres. Necesitamos el mejor "adaptado" para ser el más probable de ser elegido. Necesitamos definir la "probabilidad del mejor adaptado." Por ejemplo, un mono particularmente rápido y fuerte tiene un 90% de chance de procreación, mientras que uno débil tiene sólo una chance de 10%.</p>

<a data-primary="probability" data-type="indexterm"></a>

<p>Hagamos una pausa aquí y miremos los principios básicos de probabilidad. Primero examinémos un único evento de probabilidad, p. ej. la probabilidad que ocurra un dado evento.</p>

<p>Si tienes un sistema de ciertos números como posibles resultados, la probabilidad de que un evento dado ocurra es igual al número de resultados que califican como ese evento, dividido por el número total de todos los posibles resultados. Lanzar una moneda es un ejemplo sencillo —tiene sólo dos posibles resultados, cara o sello. Hay sólo una forma de aparezca cara. La probabilidad de que la moneda resulte como cara, por lo tanto, es uno dividido por dos: 1/5 o 50%.</p>

<p>Toma una baraja de cincuenta y dos cartas. La probabilidad de elegir un as desde el mazo es:</p>

<p><span class="formula">número de aces / número de cartas = 4 / 52 = 0.077 = ~ 8%</span></p>

<p>La probabilidad de elegir un diamante es:</p>

<p><span class="formula">número de diamantes/ número de cartas = 13 / 52 = 0.25 = 25%</span></p>

<p>Podemos también calcular la probabilidad que multiples eventos ocurran en secuencia. Para hacer esto,  simplemente multiplicamos las probabilidades individuales de cada evento.</p>

<p>La probabilidad de que una moneda de cara tres vecez seguidas es:</p>

<p><span class="formula">(1/2) * (1/2) * (1/2) = 1/8 (or 0.125)</span></p>

<p>…quiere decir que una moneda de cada tres veces seguidas es una en ocho (cada "vez" siendo tres lanzamientos).</p>

<div data-type="exercise" id="intro_exercise2">
<h5>Ejercicio I.2</h5>

<p>¿Cuál es la probabilidad de que aparezcan dos aces seguidos de una baraja de cincuenta y dos cartas?</p>
</div>

<a data-primary="arrays" data-secondary="custom distributions" data-tertiary="creating with" data-type="indexterm"></a> <a data-primary="distributions" data-secondary="non-uniform" data-tertiary="creating with arrays" data-type="indexterm"></a> <a data-primary="non-uniform distributions" data-secondary="creating with arrays" data-type="indexterm"></a> <a data-primary="random() function" data-secondary="non-uniform distributions" data-tertiary="creating with" data-type="indexterm"></a>

<p>Hay un par de maneras en donde podemos usar la función <span class="function">random()</span> con probabilidades en código. Una técnica es llenar una lista con una selección de números —con algunos de ellos se repiten— entonces elegir números aleatorios desde esa lista y generar eventos en base a esas opciones.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
int[] cosas = new int[5];
//{!2} 1 es almacenado en la lista dos veces, haciendolo más fácil de ser elegido.
cosas[0] = 1;
cosas[1] = 1;

cosas[2] = 2;
cosas[3] = 3;
stcosasuff[4] = 3;
//Elige un elemento de la lista aleatoriamente
int indice = int(random(cosas.length));</pre>

<p>Correr este código entregará un 40% de chance de imprimir el valor 1, un 20% de chance de imprimir un 2, y un 40% de chance de imprimir un 3.</p>

<p>También podemos pedir por un número aleatorio (hagámoslo más fácil y sólo consideremos un número aleatorio de punto flotante entre 0 y 1) y permitámosle a un evento que ocurra sólo si nouestro número aleatorio es entre cierto rango. Por ejemplo:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
// Una probabilidad de 10%
float probabilidad = 0.10;
// Un valor aleatorio de punto flotante entre 0 y 1
float r = random(1);
// Si nuestro número aleatorio es menor a 0.1, intenta nuevamente!
if (r &lt; probabilidad) {
  println("Intenta nuevamente!");
}</pre>

<p>Este método también puede ser aplicado a multiples resultados. Digamos que Resultado A tiene un 60% de chance de ocurrir, Resultado B, un 10% de chance, y Resultado C, un 30% de chance. Podemos implementar esto en código eligiendo un número flotante y viendo dentro del rango que cae.</p>

<ul>
	<li>
	<p><em>entre 0.00 and 0.60 (60%) &ndash;&gt; Resultado A</em></p>
	</li>
	<li>
	<p><em>entre 0.60 and 0.70 (10%) &ndash;&gt; Resultado B</em></p>
	</li>
	<li>
	<p><em>entre 0.70 and 1.00 (30%) &ndash;&gt; Resultado C</em></p>
	</li>
</ul>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
float numero = random(1);

// Si el número es menor a 0.6
if (numero &lt; 0.6) {
  println("Resultado A");
// Entre 0.6 y 0.7
} else if (numero &lt; 0.7) {
  println("Resultado B");
// Mayor que 0.7
} else {
  println("Resultado C");
}</pre>

<p>Podemos usar la metodología superior para crear un Caminante Aleatorio que tienda a moverse hacia la derecha. Aquí hay un enemplo de un <span class="klass">Caminante</span> con las siguientes probabilidades:</p>

<ul>
	<li>
	<p><em>chance de movimiento hacia arriba: 20%</em></p>
	</li>
	<li>
	<p><em>chance de movimiento hacia abajo: 20%</em></p>
	</li>
	<li>
	<p><em>chance de movimiento hacia la izquierda: 20%</em></p>
	</li>
	<li>
	<p><em>chance de movimiento hacia la derecha: 40%</em></p>
	</li>
</ul>

<figure class="screenshot" data-pde="processingjs/intro/_I_3_RandomWalkTendsToRight/_I_3_RandomWalkTendsToRight.pde processingjs/intro/_I_3_RandomWalkTendsToRight/Walker.pde"><img alt="intro ex03" src="intro/intro_ex03.png" />
<figcaption>intro ex03&nbsp;</figcaption>
</figure>

<div data-type="example">
<h5>Ejemplo I.3 Caminante que tienen a moverse hacia la derecha</h5>
</div>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  void paso() {

    float r = random(1);
    //{!2} Un 40% de chance de que se mueva a la derecha!
    if (r &lt; 0.4) {
      x++;
    } else if (r &lt; 0.6) {
      x--;
    } else if (r &lt; 0.8) {
      y++;
    } else {
      y--;
    }
  }</pre>

<div data-type="exercise" id="intro_exercise3">
<h5>Ejercicio I.3</h5>

<p>Crea un Caminante Aleatorio con posibilidades dinámicas. Por ejemplo, ¿puedes darle un 50% de chance de movimiento en la dirección de mouse?</p>
</div>
</section>

<section data-type="sect1" id="intro_section4">
<h2>I.4 A Normal Distribution of Random Numbers</h2>

<p>Let’s go back to that population of simulated Processing monkeys. Your program generates a thousand Monkey objects, each with a height value between 200 and 300 (as this is a world of monkeys that have heights between 200 and 300 pixels).</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
float h = random(200,300);</pre>

<a data-primary="distributions" data-secondary="normal" data-type="indexterm"></a> <a data-primary="probability" data-secondary="normal distributions" data-type="indexterm"></a>

<p>Does this accurately depict the heights of real-world beings? Think of a crowded sidewalk in New York City. Pick any person off the street and it may appear that their height is random. Nevertheless, it’s not the kind of random that <span class="function">random()</span> produces. People’s heights are not uniformly distributed; there are a great deal more people of average height than there are very tall or very short ones. To simulate nature, we may want it to be more likely that our monkeys are of average height (250 pixels), yet still allow them to be, on occasion, very short or very tall.</p>

<a data-primary="bell curve" data-type="indexterm"></a> <a data-primary="bell curve" data-secondary="mean and" data-type="indexterm"></a> <a data-primary="Gauss" data-secondary="Carl Friedrich" data-type="indexterm"></a> <a data-primary="Gaussian distribution" data-type="indexterm"></a> <a data-primary="Laplace" data-secondary="Pierre-Simon" data-type="indexterm"></a> <a data-primary="Laplacian distribution" data-type="indexterm"></a> <a data-primary="mean" data-type="indexterm"></a> <a data-primary="normal distribution" data-type="indexterm"></a> <a data-primary="probability" data-secondary="mean" data-type="indexterm"></a>

<p>A distribution of values that cluster around an average (referred to as the “mean”) is known as a “normal” distribution. It is also called the Gaussian distribution (named for mathematician Carl Friedrich Gauss).</p>

<p>When you graph the distribution, you get something that looks like the following, informally known as a bell curve:</p>

<figure class="two-col" id="intro_figure2"><img alt="Figure I.2" src="intro/intro_02.png" />
<figcaption>Figure I.2</figcaption>
</figure>

<figure class="two-col" id="intro_figure3"><img alt="Figure I.3" src="intro/intro_03.png" />
<figcaption>Figure I.3</figcaption>
</figure>

<a data-primary="mu (μ)" data-type="indexterm"></a> <a data-primary="sigma (σ)" data-type="indexterm"></a> <a data-primary="probability" data-secondary="standard deviation" data-type="indexterm"></a> <a data-primary="standard deviation" data-type="indexterm"></a>

<p>The curve is generated by a mathematical function that defines the probability of any given value occurring as a function of the mean (often written as &mu;, the Greek letter <em>mu</em>) and standard deviation (&sigma;, the Greek letter <em>sigma</em>).</p>

<p>The mean is pretty easy to understand. In the case of our height values between 200 and 300, you probably have an intuitive sense of the mean (i.e. average) as 250. However, what if I were to say that the standard deviation is 3 or 15? What does this mean for the numbers? The graphs above should give us a hint. The graph on the left shows us the distribution with a very low standard deviation, where the majority of the values cluster closely around the mean. The graph on the right shows us a higher standard deviation, where the values are more evenly spread out from the average.</p>

<p>The numbers work out as follows: Given a population, 68% of the members of that population will have values in the range of one standard deviation from the mean, 95% within two standard deviations, and 99.7% within three standard deviations. Given a standard deviation of 5 pixels, only 0.3% of the monkey heights will be less than 235 pixels (three standard deviations below the mean of 250) or greater than 265 pixels (three standard deviations above the mean of 250).</p>

<div data-type="note">
<h2>Calculating Mean and Standard Deviation</h2>

<p>Consider a class of ten students who receive the following scores (out of 100) on a test:</p>

<p><em>85, 82, 88, 86, 85, 93, 98, 40, 73, 83</em></p>

<p><strong><em>The mean is the average: 81.3</em></strong></p>

<a data-primary="standard deviation" data-secondary="calculating" data-type="indexterm"></a> <a data-primary="standard deviation" data-secondary="variance" data-type="indexterm"></a> <a data-primary="variance" data-type="indexterm"></a>

<p>The standard deviation is calculated as the square root of the average of the squares of deviations around the mean. In other words, take the difference from the mean for each person and square it (variance). Calculate the average of all these values and take the square root as the standard deviation.</p>

<table>
	<thead>
		<tr>
			<th>Score</th>
			<th>Difference from Mean</th>
			<th>Variance</th>
		</tr>
	</thead>
	<tfoot>
		<tr>
			<td>&nbsp;</td>
			<td>
			<p><strong>Average Variance:</strong></p>
			</td>
			<td>
			<p>228.81</p>
			</td>
		</tr>
	</tfoot>
	<tbody>
		<tr>
			<td>
			<p>85</p>
			</td>
			<td>
			<p>85-81.3 = 3.7</p>
			</td>
			<td>
			<p>(3.7)<sup>2</sup> = 13.69</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>40</p>
			</td>
			<td>
			<p>40-81.3 = -41.3</p>
			</td>
			<td>
			<p>(-41.3)<sup>2</sup> = 1705.69</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>etc.</p>
			</td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
		</tr>
	</tbody>
</table>

<p><strong><em>The standard deviation is the square root of the average variance: 15.94</em></strong></p>
</div>

<a data-primary="Processing" data-secondary="Random class" data-type="indexterm"></a> <a data-primary="Random class (Processing)" data-type="indexterm"></a>

<p>Luckily for us, to use a normal distribution of random numbers in a Processing sketch, we don’t have to do any of these calculations ourselves. Instead, we can make use of a class known as <span class="klass">Random</span>, which we get for free as part of the default Java libraries imported into Processing (see <a href="http://docs.oracle.com/javase/6/docs/api/java/util/Random.html">the JavaDocs</a> for more information).</p>

<p>To use the <span class="klass">Random</span> class, we must first declare a variable of type <span class="klass">Random</span> and create the <span class="klass">Random</span> object in <span class="function">setup()</span>.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
// We use the variable name “generator” because what we have here can be thought of as a random number generator.
Random generator;

void setup() {
  size(640, 360);
  generator = new Random();
}</pre>

<a data-primary="nextGaussian() function (Random class)" data-type="indexterm"></a> <a data-primary="Random class (Processing)" data-secondary="nextGaussian() function" data-type="indexterm"></a>

<p>If we want to produce a random number with a normal (or Gaussian) distribution each time we run through <span class="function">draw()</span>, it’s as easy as calling the function <span class="function">nextGaussian()</span>.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
void draw() {
  //{!1} Asking for a Gaussian random number. (Note nextGaussian() returns a double and must be converted to float.)
  float num = (float) generator.nextGaussian();
}</pre>

<p>Here’s the thing. What are we supposed to do with this value? What if we wanted to use it, for example, to assign the x-position of a shape we draw on screen?</p>

<a data-primary="nextGaussian() function (Random class)" data-secondary="default mean/standard deviation settings of" data-type="indexterm"></a>

<p>The <span class="function">nextGaussian()</span> function returns a normal distribution of random numbers with the following parameters: <em>a mean of zero</em> and <em>a standard deviation of one</em>. Let’s say we want a mean of 320 (the center horizontal pixel in a window of width 640) and a standard deviation of 60 pixels. We can adjust the value to our parameters by multiplying it by the standard deviation and adding the mean.</p>

<figure class="screenshot" data-pde="processingjs/intro/_I_4_Gaussian/_I_4_Gaussian.pde"><img alt="intro ex04" src="intro/intro_ex04.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<div data-type="example">
<h5>Example I.4: Gaussian distribution</h5>
</div>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
void draw() {
  //{!1} Note that nextGaussian() returns a double.
  float num = (float) generator.nextGaussian();
  float sd = 60;
  float mean = 320;

  //{!1} Multiply by the standard deviation and add the mean.
  float x = sd * num + mean;

  noStroke();
  fill(0,10);
  ellipse(x,180,16,16);
}</pre>

<p>By drawing the ellipses on top of each other with some transparency, we can actually see the distribution. The darkest spot is near the center, where most of the values cluster, but every so often circles are drawn farther to the right or left of the center.</p>

<div data-type="exercise" id="intro_exercise4">
<h5>Exercise I.4</h5>

<p>Consider a simulation of paint splatter drawn as a collection of colored dots. Most of the paint clusters around a central location, but some dots do splatter out towards the edges. Can you use a normal distribution of random numbers to generate the locations of the dots? Can you also use a normal distribution of random numbers to generate a color palette?</p>
</div>

<a data-primary="random walks" data-secondary="Gaussian" data-type="indexterm"></a>

<div data-type="exercise" id="intro_exercise5">
<h5>Exercise I.5</h5>

<p>A Gaussian random walk is defined as one in which the step size (how far the object moves in a given direction) is generated with a normal distribution. Implement this variation of our random walk.</p>
</div>
</section>

<section data-type="sect1" id="intro_section5">
<h2>I.5 A Custom Distribution of Random Numbers</h2>

<a data-primary="distributions" data-secondary="custom" data-type="indexterm"></a> <a data-primary="Lévy flight" data-type="indexterm"></a> <a data-primary="non-uniform distributions" data-secondary="custom" data-type="indexterm"></a> <a data-primary="distributions" data-secondary="non-uniform" data-tertiary="custom" data-type="indexterm"></a> <a data-primary="oversampling" data-type="indexterm"></a> <a data-primary="random number generators" data-secondary="custom distributions" data-tertiary="creating" data-type="indexterm"></a> <a data-primary="random walks" data-secondary="Lévy flight" data-type="indexterm"></a> <a data-primary="random walks" data-secondary="oversampling" data-type="indexterm"></a>

<p>There will come a time in your life when you do not want a uniform distribution of random values, or a Gaussian one. Let’s imagine for a moment that you are a random walker in search of food. Moving randomly around a space seems like a reasonable strategy for finding something to eat. After all, you don’t know where the food is, so you might as well search randomly until you find it. The problem, as you may have noticed, is that random walkers return to previously visited locations many times (this is known as “oversampling”). One strategy to avoid such a problem is to, every so often, take a very large step. This allows the walker to forage randomly around a specific location while periodically jumping very far away to reduce the amount of oversampling. This variation on the random walk (known as a L&eacute;vy flight) requires a custom set of probabilities. Though not an exact implementation of a L&eacute;vy flight, we could state the probability distribution as follows: the longer the step, the less likely it is to be picked; the shorter the step, the more likely.</p>

<p>Earlier in this prologue, we saw that we could generate custom probability distributions by filling an array with values (some duplicated so that they would be picked more frequently) or by testing the result of <span class="function">random()</span>. We could implement a L&eacute;vy flight by saying that there is a 1% chance of the walker taking a large step.</p>

<a data-primary="arrays" data-secondary="Lévy flights" data-tertiary="implementing with" data-type="indexterm"></a> <a data-primary="Lévy flight" data-secondary="implementing with arrays" data-type="indexterm"></a>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
float r = random(1);
//{$3} A 1% chance of taking a large step
if (r &lt; 0.01) {
  xstep = random(-100, 100);
  ystep = random(-100, 100);
} else {
  xstep = random(-1, 1);
  ystep = random(-1, 1);
}</pre>

<a data-primary="Lévy flight" data-secondary="implementing with qualifying random values" data-type="indexterm"></a>

<p>However, this reduces the probabilities to a fixed number of options. What if we wanted to make a more general rule—the higher a number, the more likely it is to be picked? 3.145 would be more likely to be picked than 3.144, even if that likelihood is just a tiny bit greater. In other words, if <span class="var">x</span> is the random number, we could map the likelihood on the y-axis with <span class="var">y</span> = <span class="var">x</span>.</p>

<figure id="intro_figure4"><img alt="Figure I.4" src="intro/intro_04.png" />
<figcaption>Figure I.4</figcaption>
</figure>

<p>If we can figure out how to generate a distribution of random numbers according to the above graph, then we will be able to apply the same methodology to any curve for which we have a formula.</p>

<a data-primary="non-uniform distributions" data-secondary="qualifying random values" data-type="indexterm"></a> <a data-primary="distributions" data-secondary="non-uniform" data-tertiary="qualifying random values" data-type="indexterm"></a> <a data-primary="qualifying random values" data-type="indexterm"></a>

<p>One solution is to pick two random numbers instead of one. The first random number is just that, a random number. The second one, however, is what we’ll call a “qualifying random value.” It will tell us whether to use the first one or throw it away and pick another one. Numbers that have an easier time qualifying will be picked more often, and numbers that rarely qualify will be picked infrequently. Here are the steps (for now, let’s consider only random values between 0 and 1):</p>

<ol>
	<li>
	<p>Pick a random number: R1</p>
	</li>
	<li>
	<p>Compute a probability P that R1 should qualify. Let’s try: P = R1.</p>
	</li>
	<li>
	<p>Pick another random number: R2</p>
	</li>
	<li>
	<p>If R2 is less than P, then we have found our number—R1!</p>
	</li>
	<li>
	<p>If R2 is not less than P, go back to step 1 and start over.</p>
	</li>
</ol>

<p>Here we are saying that the likelihood that a random value will qualify is equal to the random number itself. Let’s say we pick 0.1 for R1. This means that R1 will have a 10% chance of qualifying. If we pick 0.83 for R1 then it will have a 83% chance of qualifying. The higher the number, the greater the likelihood that we will actually use it.</p>

<a data-primary="Monte Carlo method" data-type="indexterm"></a> <a data-primary="non-uniform distributions" data-secondary="Monte Carlo method" data-type="indexterm"></a> <a data-primary="distributions" data-secondary="non-uniform" data-tertiary="Monte Carlo method" data-type="indexterm"></a> <a data-primary="qualifying random values" data-secondary="Monte Carlo method" data-type="indexterm"></a>

Here is a function (named for the accept-reject algorithm, a type ofMonte Carlo method, which was named for the Monte Carlo casino) that implements the above algorithm, returning a random value between 0 and 1.

<pre data-code-language="java" data-type="programlisting" class="codesplit">
float acceptreject() {
  // We do this “forever” until we find a qualifying random value.
  while (true) {
    // Pick a random value.
    float r1 = random(1);
    // Assign a probability.
    float probability = r1;
    // Pick a second random value.
    float r2 = random(1);

    //{!3} Does it qualify?  If so, we’re done!
    if (r2 &lt; probability) {
      return r1;
    }
  }
}</pre>

<div data-type="exercise" id="intro_exercise6">
<h5>Exercise I.6</h5>

<p>Use a custom probability distribution to vary the size of a step taken by the random walker. The step size can be determined by influencing the range of values picked. Can you map the probability exponentially—i.e. making the likelihood that a value is picked equal to the value squared?</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  //{!1} A uniform distribution of step sizes. Change this!
  float stepsize = random(0, 10);

  float stepx = random(-stepsize, stepsize);
  float stepy = random(-stepsize, stepsize);

  x += stepx;
  y += stepy;</pre>

<p>(Later we’ll see how to do this more efficiently using vectors.)</p>
</div>
</section>

<section data-type="sect1" id="intro_section6">
<h2>I.6 Perlin Noise (A Smoother Approach)</h2>

<a data-primary="natural phenomena" data-secondary="Perlin noise and" data-type="indexterm"></a> <a data-primary="non-uniform distributions" data-secondary="Perlin noise" data-type="indexterm"></a> <a data-primary="distributions" data-secondary="non-uniform" data-tertiary="Perlin noise" data-type="indexterm"></a> <a data-primary="Perlin noise" data-secondary="natural phenomena" data-tertiary="modeling with" data-type="indexterm"></a> <a data-primary="&lt;em&gt;Tron&lt;/em&gt; (1982)" data-type="indexterm"></a>

<p>A good random number generator produces numbers that have no relationship and show no discernible pattern. As we are beginning to see, a little bit of randomness can be a good thing when programming organic, lifelike behaviors. However, randomness as the single guiding principle is not necessarily natural. An algorithm known as “Perlin noise,” named for its inventor Ken Perlin, takes this concept into account. Perlin developed the noise function while working on the original <em>Tron</em> movie in the early 1980s; it was designed to create procedural textures for computer-generated effects. In 1997 Perlin won an Academy Award in technical achievement for this work. Perlin noise can be used to generate various effects with natural qualities, such as clouds, landscapes, and patterned textures like marble.</p>

<a data-primary="naturally ordered sequence of numbers" data-type="indexterm"></a> <a data-primary="pseudo-random numbers" data-secondary="Perlin noise and" data-type="indexterm"></a>

<p>Perlin noise has a more organic appearance because it produces a naturally ordered (“smooth”) sequence of pseudo-random numbers. The graph on the left below shows Perlin noise over time, with the x-axis representing time; note the smoothness of the curve. The graph on the right shows pure random numbers over time. (The code for generating these graphs is available in the accompanying book downloads.)</p>

<figure class="two-col"><img alt="Figure I.5: Noise" src="intro/intro_05.png" />
<figcaption>Figure I.5: Noise&nbsp;</figcaption>
</figure>

<figure class="two-col"><img alt="Figure I.6: Random" src="intro/intro_06.png" />
<figcaption>Figure I.6: Random&nbsp;</figcaption>
</figure>

<a data-primary="noise() function (Processing)" data-type="indexterm"></a> <a data-primary="Perlin noise" data-secondary="noise() function (Processing)" data-type="indexterm"></a> <a data-primary="Processing" data-secondary="noise() function" data-type="indexterm"></a>

<p>Processing has a built-in implementation of the Perlin noise algorithm: the function <span class="function">noise()</span>. The <span class="function">noise()</span> function takes one, two, or three arguments, as noise is computed in one, two, or three dimensions. Let’s start by looking at one-dimensional noise.</p>

<a data-primary="noiseDetail() function (Processing)" data-type="indexterm"></a> <a data-primary="Processing" data-secondary="noiseDetail() function" data-type="indexterm"></a>

<div data-type="note">
<h2 id="noise-detail">Noise Detail</h2>

<p>The Processing <a href="http://processing.org/reference/noise_.html">noise reference</a> tells us that noise is calculated over several “octaves.” Calling the <a href="http://processing.org/reference/noiseDetail_.html"><span class="function">noiseDetail()</span></a> function will change both the number of octaves and their importance relative to one another. This in turn changes how the noise function behaves.</p>

<p>An online lecture by Ken Perlin lets you learn more about how noise works from <a href="http://www.noisemachine.com/talk1/">Perlin himself</a>.</p>
</div>

<p>Consider drawing a circle in our Processing window at a random x-location.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
// A random x-location
float x = random(0, width);
ellipse(x, 180, 16, 16);</pre>

<p>Now, instead of a random x-location, we want a Perlin noise x-location that is “smoother.” You might think that all you need to do is replace <span class="function">random()</span> with <span class="function">noise()</span>, i.e.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
//{.line-through} A noise x-location?
float x = noise(0, width);</pre>

<a data-primary="noise() function (Processing)" data-secondary="arguments for" data-type="indexterm"></a>

<p>While conceptually this is exactly what we want to do—calculate an x-value that ranges between 0 and the width according to Perlin noise—this is not the correct implementation. While the arguments to the <span class="function">random()</span> function specify a range of values between a minimum and a maximum, <span class="function">noise()</span> does not work this way. Instead, the output range is fixed—it always returns a value between 0 and 1. We’ll see in a moment that we can get around this easily with Processing’s <span class="function">map()</span> function, but first we must examine what exactly <span class="function">noise()</span> expects us to pass in as an argument.</p>

<p>We can think of one-dimensional Perlin noise as a linear sequence of values over time. For example:</p>

<table>
	<thead>
		<tr>
			<th>Time</th>
			<th>Noise Value</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>
			<p>0</p>
			</td>
			<td>
			<p>0.365</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>1</p>
			</td>
			<td>
			<p>0.363</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>2</p>
			</td>
			<td>
			<p>0.363</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>3</p>
			</td>
			<td>
			<p>0.364</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>4</p>
			</td>
			<td>
			<p>0.366</p>
			</td>
		</tr>
	</tbody>
</table>

<p>Now, in order to access a particular noise value in Processing, we have to pass a specific "moment in time" to the <span class="function">noise()</span> function. For example:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
float n = noise(3);</pre>

<p>According to the above table, <span class="function">noise(3)</span> will return 0.364 at time equals 3. We could improve this by using a variable for time and asking for a noise value continuously in <span class="function">draw()</span>.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
float t = 3;

void draw() {
  //{!1} We need the noise value for a specific moment in time.
  float n = noise(t);
  println(n);
}</pre>

<p>The above code results in the same value printed over and over. This happens because we are asking for the result of the <span class="function">noise()</span> function at the same point in time—3—over and over. If we increment the time variable <span class="var">t</span>, however, we’ll get a different result.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
//{!1} Typically we would start at time = 0, though this is arbitrary.
float t = 0;

void draw() {
  float n = noise(t);
  println(n);
  //{!1} Now, we move forward in time!
  t += 0.01;
}</pre>

<p>How quickly we increment <span class="var">t</span> also affects the smoothness of the noise. If we make large jumps in time, then we are skipping ahead and the values will be more random.</p>

<figure id="intro_figure7"><img alt="Figure I.7" src="intro/intro_07.png" />
<figcaption>Figure I.7</figcaption>
</figure>

<p>Try running the code several times, incrementing <span class="var">t</span> by 0.01, 0.02, 0.05, 0.1, 0.0001, and you will see different results.</p>

<section data-type="sect2" id="_mapping_noise">
<h3>Mapping Noise</h3>

<a data-primary="map() function (Processing)" data-type="indexterm"></a> <a data-primary="Perlin noise" data-secondary="map() function" data-type="indexterm"></a>

<p>Now we’re ready to answer the question of what to do with the noise value. Once we have the value with a range between 0 and 1, it’s up to us to map that range to what we want. The easiest way to do this is with Processing’s <span class="function">map()</span> function. The <span class="function">map()</span> function takes five arguments. First up is the value we want to map, in this case <span class="var">n</span>. Then we have to give it the value’s current range (minimum and maximum), followed by our desired range.</p>

<figure id="intro_figure8"><img alt="Figure I.8" src="intro/intro_08.png" />
<figcaption>Figure I.8</figcaption>
</figure>

<p>In this case, we know that noise has a range between 0 and 1, but we’d like to draw our circle with a range between 0 and the window’s width.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
float t = 0;

void draw() {
  float n = noise(t);
  //{!1} Using map() to customize the range of Perlin noise
  float x = map(n, 0, 1, 0, width);
  ellipse(x, 180, 16, 16);

  t += 0.01;
}</pre>

<p>We can apply the exact same logic to our random walker, and assign both its x- and y-values according to Perlin noise.</p>

<figure class="screenshot" data-pde="processingjs/intro/_I_5_NoiseWalk/_I_5_NoiseWalk.pde processingjs/intro/_I_5_NoiseWalk/Walker.pde"><img alt="intro ex05" src="intro/intro_ex05.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<div data-type="example">
<h5>Example I.5: Perlin noise walker</h5>
</div>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
class Walker {
  float x, y;
  float tx, ty;

  Walker() {
    tx = 0;
    ty = 10000;
  }

  void step() {
    //{!2} x- and y-location mapped from noise
    x = map(noise(tx), 0, 1, 0, width);
    y = map(noise(ty), 0, 1, 0, height);

    //{!2} Move forward through “time.”
    tx += 0.01;
    ty += 0.01;
  }
}</pre>

<p>Notice how the above example requires an additional pair of variables: <span class="var">tx</span> and <span class="var">ty</span>. This is because we need to keep track of two time variables, one for the x-location of the <span class="klass">Walker</span> object and one for the y-location. But there is something a bit odd about these variables. Why does <span class="var">tx</span> start at 0 and <span class="var">ty</span> at 10,000? While these numbers are arbitrary choices, we have very specifically initialized our two time variables with different values. This is because the noise function is deterministic: it gives you the same result for a specific time <span class="var">t</span> each and every time. If we asked for the noise value at the same time <span class="var">t</span> for both <span class="var">x</span> and <span class="var">y</span>, then <span class="var">x</span> and <span class="var">y</span> would always be equal, meaning that the <span class="klass">Walker</span> object would only move along a diagonal. Instead, we simply use two different parts of the noise space, starting at 0 for <span class="var">x</span> and 10,000 for <span class="var">y</span> so that <span class="var">x</span> and <span class="var">y</span> can appear to act independently of each other.</p>

<figure id="intro_figure9"><img alt="Figure I.9" src="intro/intro_09.png" />
<figcaption>Figure I.9</figcaption>
</figure>

<p>In truth, there is no actual concept of time at play here. It’s a useful metaphor to help us understand how the noise function works, but really what we have is space, rather than time. The graph above depicts a linear sequence of noise values in a one-dimensional space, and we can ask for a value at a specific x-location whenever we want. In examples, you will often see a variable named <span class="var">xoff</span> to indicate the x-offset along the noise graph, rather than <span class="var">t</span> for time (as noted in the diagram).</p>

<div data-type="exercise" id="intro_exercise7">
<h5>Exercise I.7</h5>

<p>In the above random walker, the result of the noise function is mapped directly to the <span class="klass">Walker</span><code>’</code>s location. Create a random walker where you instead map the result of the <span class="function">noise()</span> function to a <span class="klass">Walker</span><code>’</code>s step size.</p>
</div>
</section>

<section data-type="sect2" id="_two_dimensional_noise">
<h3>Two-Dimensional Noise</h3>

<a data-primary="Perlin noise" data-secondary="two-dimensional" data-type="indexterm"></a>

<p>This idea of noise values living in a one-dimensional space is important because it leads us right into a discussion of two-dimensional space. Let’s think about this for a moment. With one-dimensional noise, we have a sequence of values in which any given value is similar to its neighbor. Because the value is in one dimension, it only has two neighbors: a value that comes before it (to the left on the graph) and one that comes after it (to the right).</p>

<figure class="two-col-borderless" id="intro_figure10"><img alt="Figure I.10: 1D Noise" src="intro/intro_10.png" />
<figcaption>Figure I.10: 1D Noise&nbsp;</figcaption>
</figure>

<figure class="two-col-borderless" id="intro_figure11"><img alt="Figure I.11: 2D Noise" src="intro/intro_11.png" />
<figcaption>Figure I.11: 2D Noise&nbsp;</figcaption>
</figure>

<p>Two-dimensional noise works exactly the same way conceptually. The difference of course is that we aren’t looking at values along a linear path, but values that are sitting on a grid. Think of a piece of graph paper with numbers written into each cell. A given value will be similar to all of its neighbors: above, below, to the right, to the left, and along any diagonal.</p>

<p>If you were to visualize this graph paper with each value mapped to the brightness of a color, you would get something that looks like clouds. White sits next to light gray, which sits next to gray, which sits next to dark gray, which sits next to black, which sits next to dark gray, etc.</p>

<figure><img alt="intro ex06" src="intro/intro_ex06.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p>This is why noise was originally invented. You tweak the parameters a bit or play with color to make the resulting image look more like marble or wood or any other organic texture.</p>

<p>Let’s take a quick look at how to implement two-dimensional noise in Processing. If you wanted to color every pixel of a window randomly, you would need a nested loop, one that accessed each pixel and picked a random brightness.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
loadPixels();
for (int x = 0; x &lt; width; x++) {
  for (int y = 0; y &lt; height; y++) {
    //{!1} A random brightness!
    float bright = random(255);
    pixels[x + y * width] = color(bright);
  }
}
updatePixels();</pre>

<p>To color each pixel according to the <span class="function">noise()</span> function, we’ll do exactly the same thing, only instead of calling <span class="function">random()</span> we’ll call <span class="function">noise()</span>.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
   //{.bold} A Perlin noise brightness!
   float bright = map(noise(x,y),0,1,0,255);</pre>

<p>This is a nice start conceptually—it gives you a noise value for every (<span class="var">x</span>,<span class="var">y</span>) location in our two-dimensional space. The problem is that this won’t have the cloudy quality we want. Jumping from pixel 200 to pixel 201 is too large of a jump through noise. Remember, when we worked with one-dimensional noise, we incremented our time variable by 0.01 each frame, not by 1! A pretty good solution to this problem is to just use different variables for the noise arguments. For example, we could increment a variable called <span class="var">xoff</span> each time we move horizontally, and a <span class="var">yoff</span> variable each time we move vertically through the nested loops.</p>

<div data-type="example">
<h5>Example I.6: 2D Perlin noise</h5>
</div>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
//{!1 .bold} Start xoff at 0.
float xoff = 0.0;

for (int x = 0; x &lt; width; x++) {
  //{!1 .bold} For every xoff, start yoff at 0.
  float yoff = 0.0;

  for (int y = 0; y &lt; height; y++) {
    //{!2 .bold} Use xoff and yoff for noise().
    float bright =
		  map(noise(xoff,yoff),0,1,0,255);
    // Use x and y for pixel location.
    pixels[x + y * width] = color(bright);
    //{!1 .bold} Increment yoff.
    yoff += 0.01;
  }
  //{!1 .bold} Increment xoff.
  xoff += 0.01;
}</pre>

<div data-type="exercise" id="intro_exercise8">
<h5>Exercise I.8</h5>

<p>Play with color, <span class="function">noiseDetail()</span>, and the rate at which <span class="var">xoff</span> and <span class="var">yoff</span> are incremented to achieve different visual effects.</p>
</div>

<div data-type="exercise" id="intro_exercise9">
<h5>Exercise I.9</h5>

<p>Add a third argument to noise that increments once per cycle through <span class="function">draw()</span> to animate the two-dimensional noise.</p>
</div>

<div data-type="exercise" id="intro_exercise10">
<h5>Exercise I.10</h5>

<p>Use the noise values as the elevations of a landscape. See the screenshot below as a reference.</p>

<figure><img alt="intro exc10" src="intro/intro_exc10.png" />
<figcaption>intro exc10&nbsp;</figcaption>
</figure>
</div>

<p>We’ve examined several traditional uses of Perlin noise in this section. With one-dimensional noise, we used smooth values to assign the location of an object to give the appearance of wandering. With two-dimensional noise, we created a cloudy pattern with smoothed values on a plane of pixels. It’s important to remember, however, that Perlin noise values are just that—values. They aren’t inherently tied to pixel locations or color. Any example in this book that has a variable could be controlled via Perlin noise. When we model a wind force, its strength could be controlled by Perlin noise. Same goes for the angles between the branches in a fractal tree pattern, or the speed and direction of objects moving along a grid in a flow field simulation.</p>

<figure class="two-col" data-pde="processingjs/intro/TreeStochasticNoise/TreeStochasticNoise.pde" id="intro_figure12"><img alt="Figure I.12: Tree with Perlin noise" src="intro/intro_12.png" />
<figcaption>Figure I.12: Tree with Perlin noise&nbsp;</figcaption>
</figure>

<figure class="two-col" data-pde="processingjs/intro/_6_04_FlowField/_6_04_FlowField.pde processingjs/intro/_6_04_FlowField/FlowField.pde processingjs/intro/_6_04_FlowField/Vehicle.pde" id="intro_figure13"><img alt="Figure I.13: Flow field with Perlin noise" src="intro/intro_13.png" />
<figcaption>Figure I.13: Flow field with Perlin noise&nbsp;</figcaption>
</figure>
</section>
</section>

<section data-type="sect1" id="intro_section7">
<h2>I.7 Onward</h2>

<p>We began this chapter by talking about how randomness can be a crutch. In many ways, it’s the most obvious answer to the kinds of questions we ask continuously—how should this object move? What color should it be? This obvious answer, however, can also be a lazy one.</p>

<p>As we finish off the introduction, it’s also worth noting that we could just as easily fall into the trap of using Perlin noise as a crutch. How should this object move? Perlin noise! What color should it be? Perlin noise! How fast should it grow? Perlin noise!</p>

<p>The point of all of this is not to say that you should or shouldn’t use randomness. Or that you should or shouldn’t use Perlin noise. The point is that the rules of your system are defined by you, and the larger your toolbox, the more choices you’ll have as you implement those rules. The goal of this book is to fill your toolbox. If all you know is random, then your design thinking is limited. Sure, Perlin noise helps, but you’ll need more. A lot more.</p>

<p>I think we’re ready to begin.</p>
</section>
</section>
